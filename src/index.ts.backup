// src/index.ts
// Express API (Railway) + MCP stdio server (Claude)

import express, { Request, Response } from "express";
import cors from "cors";
import dotenv from "dotenv";
dotenv.config();

// ------- Supabase (env + client) -------
import { createClient } from "@supabase/supabase-js";

function must(name: string) {
  const v = process.env[name];
  if (!v || v.trim() === "") throw new Error(`[BOOT] Missing env: ${name}`);
  return v.trim();
}
const SUPABASE_URL = must("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = must("SUPABASE_SERVICE_ROLE_KEY");

console.error("[BOOT] SUPABASE_URL:", SUPABASE_URL);
console.error("[BOOT] SERVICE_ROLE key length:", SUPABASE_SERVICE_ROLE_KEY.length);

export const db = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// ------- Express HTTP API (unchanged) -------
const app = express();
const PORT = process.env.PORT || 8080;

app.use(cors());
app.use(express.json());

app.use((req, _res, next) => {
  console.log(`${new Date().toISOString()} ${req.method} ${req.path}`);
  next();
});

app.get("/health", async (_req: Request, res: Response) => {
  let dbStatus = "unknown";
  try {
    const { error } = await db.from("memories").select("id", { head: true, count: "exact" });
    dbStatus = error ? `error: ${error.message}` : "connected";
  } catch (e: any) {
    dbStatus = `error: ${e?.message ?? "unknown"}`;
  }
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    version: "2.0.0",
    database: dbStatus,
    service: "recallbricks-api",
  });
});

app.get("/", (_req: Request, res: Response) => {
  res.json({
    name: "RecallBricks API",
    version: "2.0.0",
    description: "The Memory Layer for AI",
    database: "Supabase PostgreSQL",
    status: "Production Ready",
  });
});

// Keep your routers (note the `.js` for ESM-compat in built output)
import memoriesRouter from "./routes/memories.js";
import contextRouter from "./routes/context.js";
app.use("/api/v1/memories", memoriesRouter);
app.use("/api/v1", contextRouter);

// 404 + error handlers
app.use((req: Request, res: Response) => {
  res.status(404).json({
    error: "Not Found",
    message: `Route ${req.method} ${req.path} not found.`,
  });
});
app.use((err: any, _req: Request, res: Response, _next: any) => {
  console.error("Unhandled error:", err);
  res.status(500).json({
    error: "Internal Server Error",
    message: process.env.NODE_ENV === "development" ? err.message : "Something went wrong.",
  });
});

// Start HTTP (for Railway, local probing)
app.listen(PORT, () => {
  console.log("RecallBricks API v2.0.0");
  console.log("Server running on port:", PORT);
  console.log("Database: Supabase PostgreSQL");
  console.log("Ready");
});

// ------- MCP server (official SDK over stdio) -------
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  ListToolsRequestSchema,
  CallToolRequestSchema,
  type CallToolRequest,
} from "@modelcontextprotocol/sdk/types.js";

const text = (obj: unknown) => [{ type: "text", text: JSON.stringify(obj) }];

const toolDefs = [
  {
    name: "ping",
    description: "Connectivity check for MCP server",
    schema: { type: "object", properties: {}, additionalProperties: false },
  },
  {
    name: "supabase_health",
    description: "HEAD-style check against the memories table",
    schema: { type: "object", properties: {}, additionalProperties: false },
  },
  {
    name: "putMemory",
    description: "Upsert a memory row into public.memories",
    schema: {
      type: "object",
      required: ["id", "user_id", "text"],
      properties: {
        id: { type: "string", description: "UUID" },
        user_id: { type: "string", description: "UUID" },
        text: { type: "string" },
        meta: {},
      },
      additionalProperties: false,
    },
  },
  {
    name: "getMemory",
    description: "Fetch one memory by id",
    schema: {
      type: "object",
      required: ["id"],
      properties: { id: { type: "string", description: "UUID" } },
      additionalProperties: false,
    },
  },
  {
    name: "listMemories",
    description: "List recent memories for a user",
    schema: {
      type: "object",
      required: ["user_id"],
      properties: {
        user_id: { type: "string", description: "UUID" },
        limit: { type: "number", minimum: 1, maximum: 100, default: 20 },
      },
      additionalProperties: false,
    },
  },
] as const;

const mcpServer = new Server(
  { name: "recallbricks-mcp", version: "2.0.0" },
  { capabilities: { tools: {} } }
);

mcpServer.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: toolDefs.map((t) => ({
      name: t.name,
      description: t.description,
      input_schema: t.schema,
    })),
  };
});

mcpServer.setRequestHandler(CallToolRequestSchema, async (req: CallToolRequest) => {
  const name = req.params.name;
  const args = (req.params.arguments ?? {}) as Record<string, unknown>;

  try {
    if (name === "ping") {
      return { content: text({ ok: true, mcp: "up" }) };
    }

    if (name === "supabase_health") {
      const { error, count } = await db
        .from("memories")
        .select("id", { head: true, count: "exact" });
      return { content: text({ ok: !error, error: error?.message ?? null, count: count ?? null }) };
    }

    if (name === "putMemory") {
      const { id, user_id, text: bodyText, meta } = args as any;
      const { error } = await db.from("memories").upsert({
        id,
        user_id,
        text: String(bodyText),
        meta: meta ?? null,
      });
      if (error) throw new Error(error.message);
      return { content: text({ ok: true }) };
    }

    if (name === "getMemory") {
      const { id } = args as any;
      const { data, error } = await db.from("memories").select("*").eq("id", id).single();
      // PGRST116 = no rows found
      if (error && (error as any).code !== "PGRST116") throw new Error(error.message);
      return { content: text({ ok: true, memory: data ?? null }) };
    }

    if (name === "listMemories") {
      const { user_id, limit = 20 } = args as any;
      const { data, error } = await db
        .from("memories")
        .select("id,text,created_at")
        .eq("user_id", user_id)
        .order("created_at", { ascending: false })
        .limit(Number(limit));
      if (error) throw new Error(error.message);
      return { content: text({ ok: true, items: data ?? [] }) };
    }

    throw new Error(`Unknown tool: ${name}`);
  } catch (e: any) {
    return { content: text({ ok: false, error: e?.message ?? String(e) }) };
  }
});

// Connect stdio (Claude talks to this)
await mcpServer.connect(new StdioServerTransport());

// Graceful shutdown
process.on("SIGTERM", () => process.exit(0));
process.on("SIGINT", () => process.exit(0));
